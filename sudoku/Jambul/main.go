package main

// func isBoardValid([][]rune) bool {
// 	//Checks if board is valid and retruns boolean expression.
// 	//Symbols other than 1-9 should return false statement.
// 	//Must scan if there are duplicates on vertical and horizontal axes.
// 	return true
// }

// func solveSudoku([][]rune) [][]rune {
// 	//This is the main function that resolves board.
// 	//Probably backtracking would be required.
// 	//If backtracking, we can add two more boolean functions.
// 	//These functions would check columns and raws for dublicates.
// 	var a [][]rune
// 	return a
// }

// func printSudoku(str [][]rune) {
// 	//Inputs rune array and prints it in 9 lines.
// 	//In between runes should be spaces ' '.
// 	//The last symbol to print is '\n'
// 	for n, s := range str {
// 		if n%3 == 0 {
// 			for i := 0; i < 22; i++ {
// 				z01.PrintRune('-')
// 			}
// 			z01.PrintRune('\n')
// 		}
// 		for i, l := range s {
// 			if i%3 == 0 {
// 				z01.PrintRune('|')
// 			}
// 			// fmt.Print(string(l), " ")
// 			z01.PrintRune(l)
// 			z01.PrintRune(' ')
// 			if i == 8 {
// 				z01.PrintRune('|')
// 			}
// 		}
// 		z01.PrintRune('\n')
// 	}
// 	for i := 0; i < 22; i++ {
// 		z01.PrintRune('-')
// 	}
// 	z01.PrintRune('\n')
// }

func main() {
	// str := os.Args[1:]
	// //--------------------2d slice of runes ---------------------
	// arr := [][]rune{}
	// for _, x := range str {
	// 	temp := []rune{}
	// 	for _, y := range x {
	// 		temp = append(temp, y)
	// 	}
	// 	arr = append(arr, temp)
	// }
	// //------------------2d slice of runes end -------------------
}
